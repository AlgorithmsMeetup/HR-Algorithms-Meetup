{
  "name": "functional-matrix",
  "version": "0.0.3",
  "description": "A functional-programming matrix library",
  "main": "index.js",
  "scripts": {
    "test": "./node_modules/.bin/mocha test.js"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/peterkhayes/functional-matrix"
  },
  "keywords": [
    "matrix",
    "matrices",
    "2d",
    "array",
    "functional",
    "programming",
    "each",
    "forEach",
    "map",
    "reduce"
  ],
  "author": {
    "name": "Peter Hayes",
    "email": "peter.k.hayes@gmail.com",
    "url": "http://peterkhayes.com/"
  },
  "license": "BSD-2-Clause",
  "bugs": {
    "url": "https://github.com/peterkhayes/functional-matrix/issues"
  },
  "homepage": "https://github.com/peterkhayes/functional-matrix",
  "dependencies": {},
  "devDependencies": {
    "mocha": "~2.0.1",
    "chai": "~1.10.0"
  },
  "readme": "# FunctionalMatrix\n\n## Usage\n\n### Initializiation\n```javascript\n  var Matrix = require(\"functional-matrix\");\n\n  // a 2x3 matrix where all elements are \"hello\".\n  var matrix1 = new Matrix(2, 3, \"hello\");\n\n  // a 3x1 matrix with random elements.\n  var matrix2 = new Matrix(3, 1, function(i, j) {\n    return Math.random();\n  })\n\n  // a matrix from a 2d array.\n  var matrix4 = new Matrix([[1, 2], [3, 4]]);\n\n  // the 4x4 identify matrix.\n  var matrix3 = Matrix.identity(4)\n\n  // A new 2d array from the matrix.\n  var arrays = matrix4.to2dArray();\n```\n\n### Functional methods\n\n```javascript\n  var matrix1 = new Matrix(2, 3, function(i, j) {\n    return i + j;\n  });\n  // 0 1 2\n  // 1 2 3\n\n  // Make a new array through `map`.\n  var mapped = matrix1.map(function(elem, i, j) {\n    return elem * -1;\n  });\n  //  0 -1 -2\n  // -1 -2 -3\n\n  // Reduce all rows into values, creating a 1d array.\n  // Initial values can be a single value or an array (1 val for each row).\n  var rowReduced = matrix1.reduceRows(function(partial, elem, i, j) {\n    return partial + elem\n  }, [10, 20]); \n  // [13, 26]\n```\n\n### Regular matrix stuff\n\n```javascript\n  var matrix = Matrix.identity(3);\n\n  matrix.set(1, 2, \"bananas\")\n  matrix.get(1, 2); // \"bananas\"\n  matrix.equals(otherMatrix); // boolean\n  \n  matrix.add(4).add(otherMatrix).times(anotherMatrix).mod(2).determinant()\n\n  matrix.transpose() // like most methods, returns a copy.\n  matrix.pushRow([1, 2, 3]).pushCol([4, 5, 6]).shiftRow() // except these, for parity with standard array methods.\n```\n\n## Method List\n\n### Class methods\n- new Matrix(height, width, value)\n- new Matrix(height, width, fillFunction(row, col))\n- new Matrix(arrayOfArrays)\n- Identity(size)\n\n### Basics\n- .to2dArray()\n- .toString()\n- .equals(matrix)\n- .copy()\n- .set(rowIdx, colIdx, newValue)\n- .fill(fillFunction(rowIdx, colIdx))\n- .clear() - *sets all values to undefined*\n- .size() - *returns an object {rows: x, cols: y};*\n- .withinBounds(rowIdx, colIdx)\n- .rows() - *row count*\n- .cols() - *col count*\n- .get(rowIdx, colIdx)\n- .getRow(rowIdx)\n- .getCol(colIdx)\n\n### Functional Methods\nAll functional methods by default iterate from left to right, top to bottom.  Vertical versions are also provided, though.\n\n- .each(iterator(val, rowIdx, colIdx, matrix))\n- .eachHorizontal - *alias of `each`*\n- .eachVertical\n- .eachRow(iterator(row, rowIdx, matrix)) - *passes each row array to the iterator*\n- .eachCol(iterator(col, colIdx, matrix))\n- .map(iterator(val, rowIdx, colIdx, matrix))\n- .reduce(iterator(acc, val, rowIdx, colIdx, matrix))\n- .reduceHorizontal - *alias of `reduce`*\n- .reduceVertical\n- .reduceRows(iterator(acc, val, row), initial) - *collapses each row to turn matrix into 1d array*\n- .reduceCols(iterator(acc, val, col), initial)\n\n__coming soon__\n- Support for currying and partial application!\n\n### Numerical methods\n\n- .plus(number)\n- .plus(matrix)\n- .add - *alias of `plus`*\n- .minus(number)\n- .minus(matrix)\n- .subtract - *alias of `minus`*\n- .times(number)\n- .times(matrix)\n- .multiply - *alias of `times`*\n- .mod(number)\n- .determinant()\n- .rowMultiply(fromIdx, toIdx, multiple)\n\n__coming soon__\n- .inverse()\n- .upperTriangular()\n- .solveSystem(values)\n- .eigenvalues()\n\n\n### Size-changing methods\nThese work the same as the familiar array methods, except they take/return arrays. Push/pop/shift/unshift are in-place.  Concat/transpose/minor return new matrices.\n\n- .pushRow(newRow)\n- .pushCol(newCol)\n- .unshiftRow(newRow)\n- .unshiftCol(newCol)\n- .popRow()\n- .popCol()\n- .shiftRow()\n- .shiftCol()\n- .concat(matrix)\n- .concatHorizontal - *alias of `concat`*\n- .concatVertical(matrix)\n- .minor(row, col) - *the (row, col) minor of the matrix*\n- .transpose()\n\n### Query methods\n\n- .contains(elem)\n- .indexOf(elem) - *finds the first index; returns {row: x, col: y} or null*\n- .indexesOf(elem) - *returns array of all matches*\n- .count(elem)\n- .replace(elem, newElem) - *returns copy*\n\n\n\n\n\n",
  "readmeFilename": "README.md",
  "_id": "functional-matrix@0.0.3",
  "_from": "functional-matrix@"
}
