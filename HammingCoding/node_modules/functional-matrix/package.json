{
  "name": "functional-matrix",
  "version": "0.1.0",
  "description": "A functional-programming matrix library",
  "main": "index.js",
  "scripts": {
    "test": "./node_modules/.bin/mocha test.js"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/peterkhayes/functional-matrix"
  },
  "keywords": [
    "matrix",
    "matrices",
    "2d",
    "array",
    "functional",
    "programming",
    "each",
    "forEach",
    "map",
    "reduce"
  ],
  "author": {
    "name": "Peter Hayes",
    "email": "peter.k.hayes@gmail.com",
    "url": "http://peterkhayes.com/"
  },
  "license": "BSD-2-Clause",
  "bugs": {
    "url": "https://github.com/peterkhayes/functional-matrix/issues"
  },
  "homepage": "https://github.com/peterkhayes/functional-matrix",
  "dependencies": {},
  "devDependencies": {
    "mocha": "~2.0.1",
    "chai": "~1.10.0"
  },
  "readme": "# Functional Matrix\n\nAn easy-to-use library for working with two-dimensional arrays and matrices.  Most functional and array methods are implemented here, including `each`, `map`, `reduce`, `zipWith`, `every`, `push`, `pop`, `slice`, and `concat`.  Standard numerical methods, such as `multiply` and `determinant`, are also included, along with some common examples, like the identity and 2d-rotation matrices.\n\nFunctional Matrix is fully tested and throws clear error messages to aid in your debugging.\n\n## Usage\n\n### Initializiation\n```javascript\n  var Matrix = require(\"functional-matrix\");\n\n  // a 2x3 matrix where all elements are \"hello\".\n  var matrix1 = new Matrix(2, 3, \"hello\");\n\n  // a 3x1 matrix with computed elements.\n  var matrix2 = new Matrix(3, 1, function(row, col) {\n    return 10*row + 3*col;\n  })\n\n  // a matrix from a 2d array.\n  var matrix3 = new Matrix([[1, 2], [3, 4]]);\n\n  // A new 2d array from a matrix.\n  var arrays = matrix4.to2dArray();\n```\n\n### Functional methods\n\n```javascript\n  var matrix1 = new Matrix(2, 3, function(i, j) {\n    return i + j;\n  });\n  // 0 1 2\n  // 1 2 3\n\n  // Make a new array through `map`.\n  var mapped = matrix1.map(function(elem, i, j) {\n    return elem * -1;\n  });\n  //  0 -1 -2\n  // -1 -2 -3\n\n  // Reduce all rows into values, creating a 1d array.\n  // Initial values can be a single value or an array (1 val for each row).\n  var rowReduced = matrix1.reduceRows(function(partial, elem, i, j) {\n    return partial + elem\n  }, [10, 20]); \n  // [13, 26]\n```\n\n### Regular matrix stuff\n\n```javascript\n  var matrix = new Matrix(3, 4, Math.random) // 3x4 matrix of random elements\n\n  matrix.set(1, 2, \"bananas\")\n  matrix.get(1, 2); // \"bananas\"\n  matrix.equals(otherMatrix); // boolean\n  \n  // Numerical methods\n  matrix.add(4).add(otherMatrix).times(anotherMatrix).mod(2).determinant()\n\n  // Implementations of standard array methods.\n  var slice = matrix.slice(0, 0, 2, 2) // args: startRow, startCol, endRow, endCol\n  var newColCount = matrix.pushCol([5, 6, 7]); // modifies matrix in-place\n  var row = matrix.popRow(); \n  var larger = matrix.concatVertical(otherMatrix); // sizes must match\n  var idx = matrix.indexOf(1) // {row: 0, col: 0}\n  \n```\n\n## Method List\n\n### Class methods\n- new Matrix(height, width, value)\n- new Matrix(height, width, fillFunction(row, col))\n- new Matrix(arrayOfArrays)\n- .identity(size)\n- .rotation(radians) - *2d rotation matrix for given angle*\n- .rotationRadians(radians) - *alias of `rotation`*\n- .rotationDegrees(degrees)\n- .vector(array) - *a matrix with one row*\n- .vectorHorizontal(array) - *alias of `rector`*\n- .vectorVertical(array) - *like vector, but transposed*\n\n### Basics\n- .to2dArray()\n- .toString()\n- .copy()\n- .clone() - *alias of `copy`*\n- .equals(matrix)\n- .equalsRow(rowIdx, array) - *tests if row is equal to given array*\n- .equalsRow(rowIdx, matrix) - *tests if row is equal to row in other matrix*\n- .equalsCol(colIdx, array)\n- .equalsCol(colIdx, matrix)\n- .size() - *returns an object {rows: x, cols: y};*\n- .rows() - *row count*\n- .cols() - *col count*\n- .withinBounds(rowIdx, colIdx) - *boolean*\n- .get(rowIdx, colIdx)\n- .getRow(rowIdx) - *returns a copy of the indicated row*\n- .getCol(colIdx)\n- .set(rowIdx, colIdx, newValue)\n- .setRow(rowIdx, newValue) - *all entries are set to newValue*\n- .setRow(rowIdx, arrayOfNewValues) - *entries set to values in array*\n- .setRow(rowIdx, function(colIdx)) - *entries are calculated by given function*\n- .setCol(colIdx, newValue)\n- .setCol(colIdx, arrayOfNewValues)\n- .setCol(colIdx, function(rowIdx))\n- .fill(fillFunction(rowIdx, colIdx)) - *sets all values*\n- .clear() - *sets all values to undefined*\n\n### Functional Methods\nAll functional methods by default iterate from left to right, top to bottom.  Vertical versions are also provided, though.  All methods are NOT in-place and return copies.\n\n- .map(iterator(value, rowIdx, colIdx, matrix))\n- .reduce(iterator(acc, value, rowIdx, colIdx, matrix))\n- .reduceHorizontal - *alias of `reduce`*\n- .reduceVertical\n- .reduceRows(iterator(acc, value, row), initial) - *passes each row to iterator, returns an array of results*\n- .reduceCols(iterator(acc, value, col), initial) - *initial can be a value or an array of values, one per column*\n- .each(iterator(value, rowIdx, colIdx, matrix))\n- .eachHorizontal - *alias of `each`*\n- .eachVertical\n- .eachRow(iterator(row, rowIdx, matrix)) - *passes each row array to the iterator*\n- .eachCol(iterator(col, colIdx, matrix))\n- .every(iterator(value, rowIdx, colIdx))\n- .some(iterator(value, rowIdx, colIdx))\n- .zipWith(otherMatrix, iterator(thisElem, otherElem, i, j, thisMatrix, otherMatrix)) - *like `map` but with two sources of the same size*\n- .pluck(property) - *maps to named property of each element*\n- .invoke(method) - *maps to result of invoking named method of each element*\n- .sample() - *returns random element*\n- .sample(n) - *returns array of n random elements*\n- .shuffle() - *shuffles elements but maintains size*\n\n__coming soon__\n- Support for currying and partial application!\n- Right/bottom versions of each/reduce\n\n### Numerical methods\nAll methods are NOT in-place and return copies.\n\n- .plus(number)\n- .plus(matrix)\n- .add - *alias of `plus`*\n- .minus(number)\n- .minus(matrix)\n- .subtract - *alias of `minus`*\n- .times(number)\n- .times(matrix)\n- .multiply - *alias of `times`*\n- .mod(number)\n- .round(digit) - *rounds all values to the given precision*\n- .determinant()\n- .rowMultiply(fromIdx, toIdx, multiple) - *add multiple of fromRow to toRow*\n\n__coming soon__\n- .inverse()\n- .upperTriangular()\n- .solveSystem(values)\n- .eigenvalues()\n\n\n### Transforming methods\nThese work the same as the familiar array methods, except they take/return arrays. Push/pop/shift/unshift are in-place, to match arrays.  All other methods return new matrices.\n\n- .slice(startRow, startCol, endRow, endCol) - *negative indices behave like array slice*\n- .submatrix() - *alias of `slice`*\n- .pushRow(newRow) - *returns new row count*\n- .pushCol(newCol)\n- .unshiftRow(newRow)\n- .unshiftCol(newCol)\n- .popRow()\n- .popCol()\n- .shiftRow()\n- .shiftCol()\n- .concat(matrix)\n- .concatHorizontal - *alias of `concat`*\n- .concatVertical(matrix)\n- .minor(rowIdx, colIdx) - *the matrix after removing the given row and column*\n- .transpose()\n- .swapRows(rowIdx1, rowIdx2)\n- .swapCols(colIdx1, colIdx2)\n- .rotateCW()\n- .rotateCCW()\n- .flipHorizontal()\n- .flipVertical()\n\n### Query methods\n\n- .contains(elem)\n- .indexOf(elem) - *finds the first index; returns {row: x, col: y} or null*\n- .indexesOf(elem) - *returns array of all matches*\n- .count(elem)\n- .replace(elem, newElem) - *returns copy*\n\n__coming soon__\n- Support for functions and regexes in .replace\n\n\n\n\n\n",
  "readmeFilename": "README.md",
  "_id": "functional-matrix@0.1.0",
  "_from": "functional-matrix@"
}
